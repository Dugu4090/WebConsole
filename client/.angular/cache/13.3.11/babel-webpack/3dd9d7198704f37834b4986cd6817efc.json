{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { WebSocketCommandEnum } from '../_dto/command/WebSocketCommandEnum';\nimport { ConnectionStatusEnum } from '../_dto/ConnectionStatusEnum';\nimport { SettingsEnum } from './storage.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./storage.service\";\nexport let WebconsoleService = /*#__PURE__*/(() => {\n  class WebconsoleService {\n    constructor(storageService) {\n      this.storageService = storageService; //Array as Index Signature which stores ActiveConnectionDto. This object \n\n      this.activeConnections = []; //WebSocket connections stored separately, as we want all interactions with WebSockets to be done from this service.\n\n      this.webSocketClients = {}; //Subject used to notify subscribers when a server is connected or disconnected\n\n      this.activeConnectionsChangedSubject$ = new Subject();\n    }\n    /**\n     * Returns a list containing the server names WebConsole is currently connected to\n     * @returns List of Server names\n     */\n\n\n    getCurrentConnectedServers() {\n      return this.activeConnections.map(e => e.serverName);\n    }\n    /**\n     * Notifies subscribers when a server is connected or disconnected\n     * @returns Subject used to notify when a server is connected or disconnected\n     */\n\n\n    getActiveConnectionsChangedSubject() {\n      return this.activeConnectionsChangedSubject$;\n    }\n    /**\n     * Connects to a server or returns previously created one\n     * @param serverName Name of the server to connect to\n     * @returns Created connection or previously created one, if not closed.\n     */\n\n\n    connect(serverName) {\n      //If already connected to this server, return the already created Subject\n      const activeConnection = this.activeConnections.find(e => e.serverName == serverName);\n\n      if (activeConnection) {\n        return activeConnection;\n      } //If not already connected, connect to server\n\n\n      const server = this.storageService.getServer(serverName);\n      if (!server) throw Error(\"Server not found\");\n      console.log(`Connecting to ${serverName} (${server.serverURI})`);\n      const connection = this.createConnection(serverName, server.serverURI); //Save connection and return it\n\n      this.activeConnections.push(connection);\n      this.activeConnectionsChangedSubject$.next();\n      return connection;\n    }\n    /**\n     * Establish WS connection\n     * @param serverUri WebSockets URI\n     * @returns Created AnonimousSubject for this server\n     */\n\n\n    createConnection(serverName, serverUri) {\n      const ws = new WebSocket(serverUri);\n      const newConnection = {\n        serverName: serverName,\n        subject$: new Subject(),\n        connectionStatus: ConnectionStatusEnum.Connecting,\n        receivedMessages: [],\n        sentCommands: [],\n        isLoggedIn: false\n      };\n\n      ws.onopen = ev => newConnection.connectionStatus = ConnectionStatusEnum.Connected;\n\n      ws.onerror = err => newConnection.subject$.error(err);\n\n      ws.onclose = () => this.closeConnection(serverName);\n\n      ws.onmessage = msg => {\n        //Parse raw message to an actual Object\n        let parsedResponse = this.parseResponse(msg, newConnection); //Save response\n\n        newConnection.receivedMessages.push(parsedResponse); //Emit to subscribers\n\n        newConnection.subject$.next(parsedResponse);\n      }; //Store WebSocket client\n\n\n      this.webSocketClients[serverName] = ws; //Return connection\n\n      return newConnection;\n    }\n    /**\n     * Receives raw message from server and parses it to a actual WebSocketResponse object\n     * @param response\n     */\n\n\n    parseResponse(response, newConnection) {\n      let parsedJson = JSON.parse(response.data);\n\n      switch (parsedJson.status) {\n        case 10:\n          //Console output\n          return parsedJson;\n\n        case 200:\n          //LoggedIn\n          const r = parsedJson;\n          newConnection.isLoggedIn = true;\n          newConnection.token = r.token;\n          if (this.storageService.getSetting(SettingsEnum.RetrieveLogFile)) this.sendMessage(newConnection.serverName, WebSocketCommandEnum.ReadLogFile);\n          return r;\n\n        case 400:\n          //Unknown\n          return parsedJson;\n\n        case 401:\n          //Login Required\n          return parsedJson;\n\n        case 1000:\n          //Players\n          return parsedJson;\n\n        case 1001:\n          //CPU Usage\n          return parsedJson;\n\n        case 1002:\n          //RAM usage\n          return parsedJson;\n\n        case 1003:\n          //TPS\n          return parsedJson;\n\n        case 2000:\n          //File List\n          return parsedJson;\n\n        case 2001:\n          //File Read\n          return parsedJson;\n\n        case 2002:\n          //File Write\n          return parsedJson;\n\n        case 2003:\n          //File Download\n          return parsedJson;\n\n        default:\n          //Check if it's a file operation response (status 200-299)\n          if (parsedJson.status >= 200 && parsedJson.status < 300) {\n            return parsedJson;\n          } //Not recognised response\n\n\n          console.error(\"Unrecognised response:\", response);\n          return parsedJson;\n      }\n    }\n    /**\n     * Send a command to a given server\n     * @param serverName Name of the server the command is being sent to\n     * @param command Command to send\n     */\n\n\n    sendMessage(serverName, commandType, params) {\n      //Get ActiveConnection from array\n      const serverConnection = this.activeConnections.find(e => e.serverName === serverName);\n      if (!serverConnection) throw Error(`ActiveConnection not found for server ${serverName} whilst trying to send a message.`); //Get WebSocket client from array. If not found, throw error\n\n      const ws = this.webSocketClients[serverName];\n      if (!ws) throw Error(`WebSocket client not found for server ${serverName} whilst trying to send a message.`); //Build and send command if socket is open.\n\n      if (ws.readyState === WebSocket.OPEN) {\n        const command = {\n          command: commandType,\n          params: params,\n          token: serverConnection.token\n        };\n        ws.send(JSON.stringify(command));\n        serverConnection.sentCommands.push(command);\n      } else {\n        console.error(`Message to ${serverName} NOT sent because socket is not open yet.`);\n      }\n    }\n    /**\n     * Close connection with a server. This method needs to be here in order to be able to modify activeConnections$\n     * @param serverName Server name which wants connection to be closed\n     */\n\n\n    closeConnection(serverName) {\n      var _a;\n\n      const serverConnection = this.activeConnections.find(e => e.serverName === serverName);\n\n      if (serverConnection) {\n        serverConnection.subject$.complete();\n        serverConnection.connectionStatus = ConnectionStatusEnum.Disconnected;\n        (_a = this.webSocketClients[serverName]) === null || _a === void 0 ? void 0 : _a.close();\n        this.webSocketClients[serverName] = undefined;\n        this.activeConnections = this.activeConnections.filter(e => e.serverName !== serverName);\n        this.activeConnectionsChangedSubject$.next();\n      }\n    }\n\n  }\n\n  WebconsoleService.ɵfac = function WebconsoleService_Factory(t) {\n    return new (t || WebconsoleService)(i0.ɵɵinject(i1.StorageService));\n  };\n\n  WebconsoleService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: WebconsoleService,\n    factory: WebconsoleService.ɵfac,\n    providedIn: 'root'\n  });\n  return WebconsoleService;\n})();","map":null,"metadata":{},"sourceType":"module"}